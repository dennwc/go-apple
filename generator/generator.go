package generator

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/dennwc/go-doxy"
	"github.com/dennwc/go-doxy/xmlindex"
)

func NewGenerator(pkg string, dir string) (*Generator, error) {
	// TODO: remove all generated files in dir
	if err := os.RemoveAll(dir); err != nil {
		return nil, err
	}
	if err := os.MkdirAll(dir, 0755); err != nil {
		return nil, err
	}
	return &Generator{
		pkg: pkg, dir: dir,
		types:   make(map[refid]TypeDefinition),
		files:   make(map[refid]BaseNode),
		funcs:   make(map[string]*Function),
		named:   make(map[string]*NamedType),
		goFiles: make(map[string]struct{}),
	}, nil
}

type refid = string

type Generator struct {
	pkg   string
	dir   string
	types map[refid]TypeDefinition
	files map[refid]BaseNode
	funcs map[string]*Function

	named      map[string]*NamedType
	unresolved []*NamedType

	goFiles map[string]struct{}
}

func (g *Generator) fileForType(t TypeDefinition) (io.WriteCloser, error) {
	name, ok := t.GoTypeName()
	if !ok {
		return nil, nil
	}
	name = strings.ToLower(name)
	if name[0] == '_' {
		name = "t" + name
	}
	fname := filepath.Join(g.dir, name+"_gen.go")

	if _, ok := g.goFiles[name]; ok {
		f, err := os.Open(fname)
		if err != nil {
			return nil, err
		}
		if _, err = f.Seek(0, io.SeekEnd); err != nil {
			f.Close()
			return nil, err
		}
		return f, nil
	}
	g.goFiles[name] = struct{}{}

	f, err := os.Create(fname)
	if err != nil {
		return nil, err
	}
	_, err = fmt.Fprintf(f, `// Code generated by objc-gen. DO NOT EDIT!

package %s

import (
	"github.com/mkrautz/objc"
	"github.com/mkrautz/objc/Foundation"
)

var _ objc.Object
var _ = foundation.NSStringFromString

`, g.pkg)
	if err != nil {
		f.Close()
		return nil, err
	}
	return f, nil
}

func (g *Generator) LoadDoxygen(dirs ...string) error {
	for _, dir := range dirs {
		idx, err := doxy.OpenXML(dir)
		if err != nil {
			return err
		}
		for _, ent := range idx.Entries() {
			switch ent.Kind {
			case xmlindex.CompoundKindStruct,
				xmlindex.CompoundKindClass,
				xmlindex.CompoundKindInterface:
				if err := g.loadDoxyStruct(ent); err != nil {
					return err
				}
			case xmlindex.CompoundKindFile:
				if err := g.loadDoxyFile(ent); err != nil {
					return err
				}
			case xmlindex.CompoundKindProtocol:
				if err := g.loadDoxyProtocol(ent); err != nil {
					return err
				}
			default:
				//log.Println("unhandled entry type:", ent.Kind)
			}
		}
	}
	return nil
}

func (g *Generator) resolveAll() error {
	var unresolved []*NamedType
	for _, named := range g.unresolved {
		if named.Def != nil {
			continue
		}
		ok := false
		for _, def := range g.types {
			if def.getName() == named.Name {
				named.Def = def
				ok = true
				break
			}
		}
		if !ok {
			log.Printf("unresolved: %q", named.Name)
			unresolved = append(unresolved, named)
		}
	}
	g.unresolved = unresolved
	return nil
}

func (g *Generator) GenerateAll() error {
	if err := g.resolveAll(); err != nil {
		return err
	}
	for _, t := range g.types {
		f, err := g.fileForType(t)
		if err != nil {
			return err
		} else if f == nil {
			continue
		}
		t.PrintGoWrapper(f)
		if err = f.Close(); err != nil {
			return err
		}
	}
	return nil
}
